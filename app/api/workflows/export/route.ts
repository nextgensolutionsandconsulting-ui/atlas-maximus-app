
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import PptxGenJS from 'pptxgenjs'
import { jsPDF } from 'jspdf'

interface WorkflowOutput {
  workflowName: string
  content: string
  outputType: string
}

/**
 * Parse markdown content into structured sections
 */
function parseMarkdown(content: string): { title: string; content: string }[] {
  const sections: { title: string; content: string }[] = []
  const lines = content.split('\n')
  
  let currentSection: { title: string; content: string } | null = null
  
  for (const line of lines) {
    const headerMatch = line.match(/^(#{1,6})\s+(.+)$/)
    
    if (headerMatch) {
      if (currentSection) {
        sections.push(currentSection)
      }
      
      currentSection = {
        title: headerMatch[2].trim(),
        content: ''
      }
    } else if (currentSection) {
      if (line.trim()) {
        currentSection.content += line + '\n'
      }
    }
  }
  
  if (currentSection) {
    sections.push(currentSection)
  }
  
  return sections
}

/**
 * Clean markdown formatting from text
 */
function cleanMarkdown(text: string): string {
  return text
    .replace(/\*\*(.+?)\*\*/g, '$1')
    .replace(/\*(.+?)\*/g, '$1')
    .replace(/`(.+?)`/g, '$1')
    .replace(/\[(.+?)\]\(.+?\)/g, '$1')
    .trim()
}

/**
 * Split long text into chunks
 */
function splitIntoChunks(text: string, maxLines: number = 15): string[] {
  const lines = text.split('\n').filter(line => line.trim())
  const chunks: string[] = []
  
  for (let i = 0; i < lines.length; i += maxLines) {
    chunks.push(lines.slice(i, i + maxLines).join('\n'))
  }
  
  return chunks
}

/**
 * Export as PowerPoint
 */
async function exportToPowerPoint(output: WorkflowOutput): Promise<Buffer> {
  const pptx = new PptxGenJS()
  
  pptx.author = 'Atlas Maximus'
  pptx.company = 'Atlas Maximus - Agile Learning Platform'
  pptx.subject = output.workflowName
  pptx.title = output.workflowName
  
  const colors = {
    primary: '2563EB',
    secondary: '7C3AED',
    text: '1F2937',
    light: 'F3F4F6'
  }
  
  // Title slide
  const titleSlide = pptx.addSlide()
  titleSlide.background = { color: colors.primary }
  
  titleSlide.addText(output.workflowName, {
    x: 0.5,
    y: 2.5,
    w: 9,
    h: 1.5,
    fontSize: 44,
    bold: true,
    color: 'FFFFFF',
    align: 'center'
  })
  
  titleSlide.addText('Generated by Atlas Maximus', {
    x: 0.5,
    y: 4.0,
    w: 9,
    h: 0.5,
    fontSize: 18,
    color: 'FFFFFF',
    align: 'center'
  })
  
  titleSlide.addText(new Date().toLocaleDateString(), {
    x: 0.5,
    y: 4.6,
    w: 9,
    h: 0.4,
    fontSize: 14,
    color: 'E5E7EB',
    align: 'center'
  })
  
  const sections = parseMarkdown(output.content)
  let slideNumber = 2
  
  for (const section of sections) {
    const contentChunks = splitIntoChunks(section.content, 12)
    
    for (let i = 0; i < contentChunks.length; i++) {
      const slide = pptx.addSlide()
      
      slide.addShape(pptx.ShapeType.rect, {
        x: 0,
        y: 0,
        w: 10,
        h: 0.8,
        fill: { color: colors.primary }
      })
      
      const slideTitle = i === 0 ? section.title : `${section.title} (continued)`
      
      slide.addText(slideTitle, {
        x: 0.3,
        y: 0.15,
        w: 9.4,
        h: 0.5,
        fontSize: 24,
        bold: true,
        color: 'FFFFFF'
      })
      
      const cleanContent = cleanMarkdown(contentChunks[i])
      const contentLines = cleanContent.split('\n').filter(line => line.trim())
      
      let yPosition = 1.2
      
      for (const line of contentLines) {
        const isBullet = line.trim().startsWith('-') || line.trim().startsWith('•')
        const text = line.replace(/^[-•]\s*/, '').trim()
        
        if (text) {
          slide.addText(text, {
            x: isBullet ? 0.8 : 0.5,
            y: yPosition,
            w: 8.7,
            fontSize: 14,
            color: colors.text,
            bullet: isBullet ? { code: '2022' } : false,
            valign: 'top'
          })
          
          yPosition += 0.4
        }
      }
      
      slide.addText(`Slide ${slideNumber} | ${output.workflowName}`, {
        x: 0.5,
        y: 5.2,
        w: 9,
        h: 0.3,
        fontSize: 10,
        color: '9CA3AF',
        align: 'center'
      })
      
      slideNumber++
    }
  }
  
  if (sections.length === 0) {
    const slide = pptx.addSlide()
    slide.addText('Output', {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 0.6,
      fontSize: 28,
      bold: true,
      color: colors.primary
    })
    
    slide.addText(output.content.substring(0, 1000), {
      x: 0.5,
      y: 1.3,
      w: 9,
      h: 4,
      fontSize: 12,
      color: colors.text,
      valign: 'top'
    })
  }
  
  const buffer = await pptx.write({ outputType: 'nodebuffer' }) as Buffer
  return buffer
}

/**
 * Export as PDF
 */
function exportToPDF(output: WorkflowOutput): Buffer {
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  })
  
  const pageWidth = doc.internal.pageSize.getWidth()
  const pageHeight = doc.internal.pageSize.getHeight()
  const margin = 20
  const maxWidth = pageWidth - (margin * 2)
  
  let yPosition = margin
  
  const checkNewPage = (height: number) => {
    if (yPosition + height > pageHeight - margin) {
      doc.addPage()
      yPosition = margin
      return true
    }
    return false
  }
  
  // Title page
  doc.setFillColor(37, 99, 235)
  doc.rect(0, 0, pageWidth, 80, 'F')
  
  doc.setTextColor(255, 255, 255)
  doc.setFontSize(32)
  doc.setFont('helvetica', 'bold')
  doc.text(output.workflowName, pageWidth / 2, 40, { align: 'center' })
  
  doc.setFontSize(14)
  doc.setFont('helvetica', 'normal')
  doc.text('Generated by Atlas Maximus', pageWidth / 2, 55, { align: 'center' })
  
  doc.setFontSize(12)
  doc.text(new Date().toLocaleDateString(), pageWidth / 2, 65, { align: 'center' })
  
  doc.addPage()
  yPosition = margin
  
  doc.setTextColor(31, 41, 55)
  
  const sections = parseMarkdown(output.content)
  
  if (sections.length > 0) {
    for (const section of sections) {
      checkNewPage(15)
      doc.setFontSize(18)
      doc.setFont('helvetica', 'bold')
      doc.setTextColor(37, 99, 235)
      doc.text(section.title, margin, yPosition)
      yPosition += 10
      
      doc.setFontSize(11)
      doc.setFont('helvetica', 'normal')
      doc.setTextColor(31, 41, 55)
      
      const cleanContent = cleanMarkdown(section.content)
      const lines = cleanContent.split('\n').filter(line => line.trim())
      
      for (const line of lines) {
        checkNewPage(8)
        
        const isBullet = line.trim().startsWith('-') || line.trim().startsWith('•')
        const text = line.replace(/^[-•]\s*/, '').trim()
        
        if (text) {
          const wrappedText = doc.splitTextToSize(text, maxWidth - (isBullet ? 10 : 0))
          
          if (isBullet) {
            doc.text('•', margin + 2, yPosition)
            doc.text(wrappedText, margin + 10, yPosition)
          } else {
            doc.text(wrappedText, margin, yPosition)
          }
          
          yPosition += wrappedText.length * 6
        }
      }
      
      yPosition += 8
    }
  } else {
    doc.setFontSize(11)
    doc.setFont('helvetica', 'normal')
    const wrappedContent = doc.splitTextToSize(output.content, maxWidth)
    
    for (const line of wrappedContent) {
      checkNewPage(6)
      doc.text(line, margin, yPosition)
      yPosition += 6
    }
  }
  
  const pageCount = doc.getNumberOfPages()
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i)
    doc.setFontSize(10)
    doc.setTextColor(156, 163, 175)
    doc.text(
      `Page ${i} of ${pageCount}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    )
  }
  
  return Buffer.from(doc.output('arraybuffer'))
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user?.email) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { format, workflowName, content, outputType } = await request.json()

    if (!format || !workflowName || !content) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    const output: WorkflowOutput = { workflowName, content, outputType }

    if (format === 'pptx') {
      const buffer = await exportToPowerPoint(output)
      
      return new NextResponse(buffer, {
        headers: {
          'Content-Type': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
          'Content-Disposition': `attachment; filename="${workflowName.replace(/\s+/g, '-')}-${Date.now()}.pptx"`
        }
      })
    } else if (format === 'pdf') {
      const buffer = exportToPDF(output)
      
      return new NextResponse(buffer, {
        headers: {
          'Content-Type': 'application/pdf',
          'Content-Disposition': `attachment; filename="${workflowName.replace(/\s+/g, '-')}-${Date.now()}.pdf"`
        }
      })
    } else {
      return NextResponse.json(
        { error: 'Invalid format. Use "pptx" or "pdf"' },
        { status: 400 }
      )
    }

  } catch (error) {
    console.error('Export error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to export' },
      { status: 500 }
    )
  }
}
